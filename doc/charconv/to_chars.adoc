////
Copyright 2023 Matt Borland
Distributed under the Boost Software License, Version 1.0.
https://www.boost.org/LICENSE_1_0.txt
////

= to_chars
:idprefix: to_chars_

== to_chars overview
[source, c++]
----
struct to_chars_result
{
    char* ptr;
    int ec;

    friend constexpr bool operator==(const to_chars_result& lhs, const to_chars_result& rhs) noexcept;
    friend constexpr bool operator!=(const to_chars_result& lhs, const to_chars_result& rhs) noexcept;
};

template <typename Integral>
BOOST_CHARCONV_CONSTEXPR to_chars_result(char* first, char* last, Integral value, int base = 10) noexcept;

template <typename Integral>
BOOST_CHARCONV_CONSTEXPR to_chars_result<bool>(char* first, char* last, Integral value, int base) noexcept = delete;

template <typename Real>
to_chars_result(char* first, char* last, Real value, chars_format fmt = chars_format::general, int precision) noexcept;
----

== to_chars_result
* ptr - points to the first character
* ec - the error code. Valid values from <cerrno> are:
** 0 - successful parsing
** EINVAL - invalid argument
** ERANGE - result out of range (e.g. overflow)
* operator== - compares the value of ptr and ec for equality
* operator!= - compares the value of ptr and ec for inequality

== to_chars
* first, last - pointers to the character buffer
* value - the value to be paresed into the buffer
* base (integer only) - the integer base to use. Must be between 2 and 36 inclusive
* fmt (float only) - the floating point format to use.
See xref:chars_format.adoc[chars_format overview] for description.
* precision (float only) - the number of decimal places required

=== to_chars for integral types
* All built-in integral types are allowed except bool which is deleted
* from_chars for integral type is constexpr (BOOST_CHARCONV_CONSTEXPR is defined) when compiled using `-std=c++14` or newer and a compiler with `__builtin_ is_constant_evaluated`
* These functions have been tested to support `__int128` and `unsigned __int128`

=== to_chars for floating point types
* The following will be returned when handling different values of `NaN`
** +qNaN returns "nan"
** -qNaN returns "-nan(ind)"
** +sNaN returns "nan(snan)"
** -sNaN returns "-nan(snan)"

== Examples

=== Basic Usage
==== Integral
[source, c++]
----
char buffer[64] {};
int v = 42;
to_chars_result r = boost::charconv::to_chars(buffer, buffer + sizeof(buffer) - 1, v);
assert(r.ec == 0);
assert(!strcmp(buffer, "42")); // strcmp returns 0 on match
----
==== Floating Point
[source, c++]
----
char buffer[64] {};
double v = 1e300;
to_chars_result r = boost::charconv::to_chars(buffer, buffer + sizeof(buffer) - 1, v);
assert(r.ex == 0);
assert(!strcmp(buffer, "1e+300"));
----

=== Hexadecimal
==== Integral
[source, c++]
----
char buffer[64] {};
int v = 42;
to_chars_result r = boost::charconv::to_chars(buffer, buffer + sizeof(buffer) - 1, v, 16);
assert(r.ec == 0);
assert(!strcmp(buffer, "2a")); // strcmp returns 0 on match
----
==== Floating Point
[source, c++]
----
char buffer[64] {};
double v = -1.08260383390082946e+307;
to_chars_result r = boost::charconv::to_chars(buffer, buffer + sizeof(buffer) - 1, v, boost::charconv::chars_format::hex);
assert(r.ex == 0);
assert(!strcmp(buffer, "-1.ed5658af91a0fp+1019"));
----

=== ERANGE
==== Integral
[source, c++]
----
char buffer[3] {};
int v = -1234;
to_chars_result r = boost::charconv::to_chars(buffer, buffer + sizeof(buffer) - 1, v, 16);
assert(r.ec == ERANGE);
----
==== Floating Point
[source, c++]
----
char buffer[3] {};
double v = 1.2345;
auto r = boost::charconv::to_chars(buffer, buffer + sizeof(buffer) - 1, v);
assert(r.ec == ERANGE);
----

In the event of ERANGE to_chars_result.ptr is first
